import { promises } from 'node:fs'
import { resolve } from 'node:path'
import { describe, expect, it } from 'vitest'

import part1 from './part-1'
import part2 from './part-2'

let data = promises.readFile(resolve(__dirname, '../../../data/2019-10.txt'), 'utf8')

describe('Part 1', () => {
  it.each([
    [8, '3,4', ['.#..#', '.....', '#####', '....#', '...##'].join('\n')],
    [
      33,
      '5,8',
      [
        '......#.#.',
        '#..#.#....',
        '..#######.',
        '.#.#.###..',
        '.#..#.....',
        '..#....#.#',
        '#..#....#.',
        '.##.#..###',
        '##...#..#.',
        '.#....####',
      ].join('\n'),
    ],
    [
      35,
      '1,2',
      [
        '#.#...#.#.',
        '.###....#.',
        '.#....#...',
        '##.#.#.#.#',
        '....#.#.#.',
        '.##..###.#',
        '..#...##..',
        '..##....##',
        '......#...',
        '.####.###.',
      ].join('\n'),
    ],
    [
      41,
      '6,3',
      [
        '.#..#..###',
        '####.###.#',
        '....###.#.',
        '..###.##.#',
        '##.##.#.#.',
        '....###..#',
        '..#.#..#.#',
        '#..#.#.###',
        '.##...##.#',
        '.....#.#..',
      ].join('\n'),
    ],
    [
      210,
      '11,13',
      [
        '.#..##.###...#######',
        '##.############..##.',
        '.#.######.########.#',
        '.###.#######.####.#.',
        '#####.##.#.##.###.##',
        '..#####..#.#########',
        '####################',
        '#.####....###.#.#.##',
        '##.#################',
        '#####.##.###..####..',
        '..######..##.#######',
        '####.##.####...##..#',
        '.#####..#.######.###',
        '##...#.##########...',
        '#.##########.#######',
        '.####.#.###.###.#.##',
        '....##.##.###..#####',
        '.#.#.###########.###',
        '#.#.#.#####.####.###',
        '###.##.####.##.#..##',
      ].join('\n'),
    ],
  ])('The map requires an output of "%s" at position "%s"', (output, position, input) => {
    expect(part1.sensorBoost(input).visible_asteroids).toEqual(output)
  })

  // Actual test, Part 1
  it('should produce the correct value for the input data', async () => {
    expect(part1.sensorBoost(await data).visible_asteroids).toMatchSnapshot()
  })
})

describe('Part 2', () => {
  it('Should find the best monitoring system, and get the 200th vaporized asteroid', async () => {
    let map = [
      '.#..##.###...#######',
      '##.############..##.',
      '.#.######.########.#',
      '.###.#######.####.#.',
      '#####.##.#.##.###.##',
      '..#####..#.#########',
      '####################',
      '#.####....###.#.#.##',
      '##.#################',
      '#####.##.###..####..',
      '..######..##.#######',
      '####.##.####...##..#',
      '.#####..#.######.###',
      '##...#.##########...',
      '#.##########.#######',
      '.####.#.###.###.#.##',
      '....##.##.###..#####',
      '.#.#.###########.###',
      '#.#.#.#####.####.###',
      '###.##.####.##.#..##',
    ].join('\n')

    // 802 because 8,2 => x * 100 + y
    expect(part2.findVaporizedAsteroid(map, 200)).toEqual(802)
  })

  // Actual test, Part 2
  it('should produce the correct value for the input data', async () => {
    expect(part2.findVaporizedAsteroid(await data, 200)).toMatchSnapshot()
  })
})
